import subprocess
from pathlib import Path
from time import time
from typing import Any, Dict, List, Set, Tuple, TypedDict, Union
import requests
import json
import re

"""
The ultimate script to create angular api services from openapi definitions.
"""

SRC = Path(__file__).absolute().parent / "src" / "ui"
URL = "http://localhost:8015/openapi.json"
GEN = Path(__file__).absolute().parent / "src" / "ui" / "src" / "app" / "gen"
GEN.mkdir(exist_ok=True)
HEADER = "// This file is automatically generated. Don't edit."


# Removes all those models that are not used, this kidn of recursion is ok because there can't be cyclic dependencies
def recursively_solve_used(used: Set[str], models: dict) -> Set[str]:
    return_used = [i for i in used]
    new_allowed = []
    for k, v in models.items():
        if not k in used:
            continue
        lines = json.dumps(v, indent=2).splitlines()
        for i in lines:
            if "$ref" in i:
                obj = i.split("/")[-1].replace('"', "").strip()
                new_allowed.append(obj)
    if len(new_allowed) > 0:
        return_used += list(recursively_solve_used(set(new_allowed), models))
    return set(return_used)


def camel_to_kebab(string: str) -> str:
    string = re.sub("(.)([A-Z][a-z]+)", r"\1-\2", string)
    return re.sub("([a-z0-9])([A-Z])", r"\1-\2", string).lower()


def convert_file_name(file_name: str) -> str:
    file_name = file_name.replace("DTO", ".dto").replace("Enum", ".enum")
    return re.sub(r"(?<!^)(?=[A-Z])", "-", file_name).lower()


def get_type_str(any: dict) -> Tuple[str, List[str]]:
    if "$ref" in any:
        ref = any["$ref"].split("/")[-1].replace('"', "").strip()
        return ref, [ref]
    if any.get("type", "") in {"string", "object"}:
        return any["type"], []
    if any.get("type", "") == "integer":
        return "number", []
    if any.get("type", "") == "array":
        type_str, imports = get_type_str(any["items"])
        return "Array<" + type_str + ">", imports
    if "anyOf" in any:
        imports = []
        options = []
        for i in any["anyOf"]:
            option, export = get_type_str(i)
            imports.extend(export)
            options.append(option)
        return " | ".join(options), imports
    return "unknown", []


def get_model(name: str, schema: Any):
    if "enum" in schema:
        values = [f'{i} = "{i}"' for i in schema["enum"]]
        values.sort()
        return f"export enum {name} {{{','.join(values)}}}"
    members = []
    imports = []
    for k, v in schema["properties"].items():
        required_symbol = "" if k in schema.get("required", {}) else "?"
        type_str, new_imports = get_type_str(v)
        imports.extend(new_imports)
        members.append(f"{k}{required_symbol}: {type_str}")
    imports.sort()
    import_lines = [
        f'import {{{i}}} from "./{convert_file_name(i)}";' for i in imports
    ]

    return (
        "\n".join(import_lines)
        + f"\n\nexport interface {name} {{"
        + ";".join(members)
        + "}"
    )


def create_models(used_models: Set[str]):
    schema = requests.get(URL).json()["components"]["schemas"]
    models = GEN / "models"
    models.mkdir(exist_ok=True)
    subprocess.check_call(f"rm -rf {models}/*.ts", shell=True)
    models.mkdir(exist_ok=True)
    used = list(recursively_solve_used(used_models, schema))
    used.sort()
    for i in used:
        content = get_model(i, schema[i])
        file_name = convert_file_name(i)
        with open(models / f"{file_name}.ts", "w") as f:
            f.write(HEADER + "\n" + content)
    write_index(models)


def write_index(root: Path):
    exports = []
    for i in root.glob("*.ts"):
        key = str(i).replace(".ts", "").split("/")[-1]
        exports.append(key)
    exports.sort()
    with open(root / "index.ts", "w") as f:
        f.write(
            HEADER
            + "\n"
            + "\n".join([f"export * from './{i}'" for i in exports])
        )


class Service(TypedDict):
    name: str
    imports: List[str]
    code: str


def get_response_dto(item: dict) -> Union[str, None]:
    ref = (
        item.get("responses", {})
        .get("200", {})
        .get("content", {})
        .get("application/json", {})
        .get("schema", {})
        .get("$ref", "")
    )
    if ref == "":
        return None
    return ref.split("/")[-1]


def get_request_dto(item: dict) -> Union[str, None]:
    ref = (
        item.get("requestBody", {})
        .get("content", {})
        .get("application/json", {})
        .get("schema", {})
        .get("$ref", "")
    )
    if ref == "":
        return None
    return ref.split("/")[-1]


def get_path_parameters(item: dict) -> Dict[str, str]:
    def get_ts_type(t: str) -> str:
        return t

    return {
        i["name"]: get_ts_type(i["schema"]["type"])
        for i in item.get("parameters", [])
    }


def find_service(path: str, item: dict) -> Union[Service, None]:
    service = [i for i in path.split("/") if i != ""]
    # Service name is always in the second path. It's like /api/{service-name}/...
    if len(service) < 2:
        return None
    name = service[1]
    method = list(item.keys())[0]
    definition = list(item.values())[0]
    response_dto = get_response_dto(definition)
    request_dto = get_request_dto(definition)
    path_params = get_path_parameters(definition)
    summary = definition["summary"].split(" ")
    method_name = "".join([summary[0].lower()] + summary[1:])
    path_params_to_subs = "{" + (",".join(path_params.keys())) + "}"
    params = [f"{k}: {v}" for k, v in path_params.items()]
    http_params = ["url"]
    if request_dto is not None:
        params.append(f"dto: {request_dto}")
        http_params.append("dto")
    params_str = ",".join(params)
    http_params_str = ",".join(http_params)
    sub_path = path.replace("{", ":").replace("}", "")
    return {
        "name": name,
        "imports": [i for i in [response_dto, request_dto] if i is not None],
        "code": "\n".join(
            [
                f"{method_name}({params_str}): Observable<{response_dto}> {{",
                f'const url = subsToUrl("{sub_path}", {path_params_to_subs});',
                f"return this.http.{method}<{response_dto}>({http_params_str});",
                "}",
            ]
        ),
    }


def create_api() -> Set[str]:
    schema = requests.get(URL).json()
    # print(json.dumps(schema, indent=2))
    services = {}
    apis = GEN / "apis"
    apis.mkdir(exist_ok=True)
    subprocess.check_call(f"rm -rf {apis}/*.ts", shell=True)
    apis.mkdir(exist_ok=True)
    for path, item in schema["paths"].items():
        service = find_service(path, item)
        if service is None:
            continue
        if service["name"] not in services:
            services[service["name"]] = {"code": [], "imports": []}
        services[service["name"]]["code"].append(service["code"])
        services[service["name"]]["imports"] += service["imports"]
    files = []
    all_imports = []
    for service, methods in services.items():
        dto_imports = list(set(methods["imports"]))
        dto_imports.sort()
        all_imports += dto_imports
        service_code = methods["code"]
        service_code.sort()
        service_name = f"{service.capitalize()}ApiService"
        code = (
            HEADER
            + """
import { HttpClient } from "@angular/common/http";
import { Injectable } from "@angular/core";
import { Observable } from "rxjs";
import { subsToUrl } from "./../subs-to-url.func";
import {
"""
            + (",".join(dto_imports))
            + """
} from "../models/index";

@Injectable({
  providedIn: "root",
})
export class """
            + service_name
            + """ {
    constructor(private http: HttpClient) {}

    """
            + ("\n\n".join(service_code))
            + "}"
        )
        file_name = camel_to_kebab(service) + "-api.service.ts"
        with open(apis / file_name, "w") as f:
            f.write(code)
    write_index(apis)

    return set(all_imports)


if __name__ == "__main__":
    start = time()
    used_models = create_api()
    create_models(used_models)
    # Run npx in this order, so that compilation succeeds because apis were modified last
    dirs = ["models", "apis"]
    for i in dirs:
        subprocess.check_call(
            "npx prettier *.ts --write ",
            shell=True,
            universal_newlines=True,
            cwd=GEN / i,
        )
    print(f"Finished. Total duration {time() - start} s.")
